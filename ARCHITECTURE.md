# Architecture Documentation

This document defines the architectural patterns, principles, and conventions used in this project. **Always follow these guidelines when generating new code.**

## Project Structure

```
libs/
├── common/              # Shared utilities, interfaces, constants
├── domain_layer/        # Domain logic (pure, no infrastructure dependencies)
│   ├── domain_services/    # Static domain services (no DI)
│   ├── domain_factories/   # Domain entity factories
│   ├── entities/           # Domain entities
│   ├── value_objects/      # Immutable value objects
│   └── domain_error.py     # Domain-specific errors
├── application_layer/   # Application orchestration layer
│   ├── commands/           # CQRS commands
│   │   ├── command_objects/    # Command DTOs
│   │   └── command_handlers/   # Command handlers
│   ├── queries/             # CQRS queries (synchronous, return DTOs)
│   ├── mappers/             # Mapping between layers (Entity ↔ DAO, Entity ↔ DTO)
│   ├── dtos/                # Data Transfer Objects
│   └── services/            # Application services
└── infrastructure_layer/ # Technical concerns
    ├── db_readers/          # Database readers
    ├── db_writers/          # Database writers
    ├── file_readers/        # File system readers
    ├── data_access_objects/ # DAOs (SQLAlchemy ORM models)
    └── session_factory.py   # Database session management

batch/                   # Batch job application
webapi/                  # Web API application
```

## Domain-Driven Design (DDD)

### Core Principles

1. **Domain Layer is Pure**: The domain layer must NOT depend on:
   - Infrastructure (databases, file systems, HTTP)
   - Application layer
   - Frameworks (ORM, web frameworks)
   - Logging libraries
   - External services
   - **Business constants**: Domain rules (like min/max ranges) should be explicit i domain layer, not configurable parameters, configuraiton and configurable parameter belongs to applicaiton or infrastructure layer

2. **Domain Layer Returns Either**: Domain operations return `Either[Success, DomainError]` instead of raising exceptions. Use `Left` for errors, `Right` for success.

3. **No DI in Domain Layer**: Domain services and factories are static classes/functions. No dependency injection.

### Entities

**What is an Entity:**
- Has a unique identity (ID)
- Can be mutable (state can change)
- Enforces business invariants
- Must be created through a factory method (e.g., `Entity.create()`)
- Direct instantiation is blocked via `__new__`

**Entity Rules:**
- File naming: `xxx__entity.py`
- Class naming: `XxxEntity`
- Must have a `create()` static method that returns `Either[Entity, DomainError]`
- ID is generated by the entity itself (not from outside)
- Use `__setattr__` to protect immutable fields (e.g., `_id`)
- Validation happens in `create()`, not in a separate `validate()` method

**Example:**
```python
class WalnutEntity:
    def __new__(cls, ...):
        raise RuntimeError("Use WalnutEntity.create() instead")
    
    @staticmethod
    def create(...) -> Either[WalnutEntity, DomainError]:
        # Validation and creation logic
        return Right(entity)
```

### Value Objects

**What is a Value Object:**
- Immutable
- No unique identity (equality by value)
- Represents a descriptive aspect of the domain
- File naming: `xxx__value_object.py`
- Class naming: `XxxValueObject` (must match file name pattern)

**Naming Consistency Rule:**
- **File name and class name must be consistent**: If file is `dimension__value_object.py`, class must be `DimensionValueObject` or `WalnutDimensionValueObject`
- Pattern: `{DomainConcept}{FileType}` where FileType is `ValueObject`, `Entity`, `DomainService`, etc.
- Example: `dimension__value_object.py` → `WalnutDimensionValueObject`

**Value Object Validation:**
- **Invariants belong in the value object**: Rules about the value itself are validated in the value object
- **Use factory methods**: Create value objects via `create()` or `from_*()` class methods
- **Return Either**: Factory methods return `Either[ValueObject, DomainError]` for explicit error handling
- **Business constants**: Domain rules (like min/max ranges) should be class constants, not configurable parameters

**Example:**
```python
@dataclass(frozen=True)
class WalnutDimensionValueObject:
    x_mm: float
    y_mm: float
    z_mm: float
    
    MIN_MM = 20.0  # Business constant
    MAX_MM = 50.0  # Business constant
    
    @classmethod
    def create(cls, x_mm: float, y_mm: float, z_mm: float) -> Either["WalnutDimensionValueObject", DomainError]:
        # Validate all invariants here
        if min(x_mm, y_mm, z_mm) <= 0:
            return Left(ValidationError("All dimensions must be positive"))
        # ... more validation
        return Right(cls(x_mm, y_mm, z_mm))
```

**Value Object vs Entity Validation:**
- **Value Object**: Validates intrinsic properties of the value itself (e.g., "dimensions must be positive")
- **Entity**: Validates contextual rules involving multiple values or entities (e.g., "extra large walnut must have length >= 45mm")

### Domain Services

**What is a Domain Service:**
- Static class with static methods
- Contains domain logic that doesn't belong to a single entity
- No DI, no interfaces
- File naming: `xxx__domain_service.py`
- Class naming: `XxxDomainService`

**Example:**
```python
class ImageEmbeddingDomainService:
    @staticmethod
    def generate(image_path: str) -> np.ndarray:
        # Domain logic here
        pass
```

### Domain Factories

**What is a Domain Factory:**
- Creates domain entities from various inputs
- Returns `Either[Entity, DomainError]`
- File naming: `xxx__domain_factory.py`
- Class naming: `XxxDomainFactory`

**Example:**
```python
class WalnutDomainFactory:
    @staticmethod
    def create_from_images(images: Dict[str, ImageValueObject]) -> Either[WalnutEntity, DomainError]:
        return WalnutEntity.create(...)
```

### Domain Errors

**What is a Domain Error:**
- Domain-specific error classes
- Inherit from `DomainError`
- Used in `Either[Success, DomainError]` return types
- File: `domain_layer/domain_error.py`

## CQRS (Command Query Responsibility Segregation)

### Commands

**What is a Command:**
- Modifies state (creates, updates, deletes)
- Returns `None` (void)
- Asynchronous execution via `CommandDispatcher`
- File naming: `xxx__command.py` in `commands/command_objects/`
- Class naming: `CreateXxxCommand`, `UpdateXxxCommand`, etc.

**Command Flow:**
1. Application layer creates a command object
2. Calls `command_dispatcher.dispatch(command)`
3. Dispatcher finds and executes the appropriate handler
4. Handler performs business logic through domain layer
5. Handler saves changes via infrastructure layer

**Command Handler:**
- File naming: `xxx__command_handler.py` in `commands/command_handlers/`
- Class naming: `CreateXxxHandler`
- Implements `ICommandHandler[CommandType]`
- Receives dependencies via DI
- Uses domain factories to create entities
- Maps entities to DAOs via mappers
- Saves via infrastructure writers


### Queries

**What is a Query:**
- Reads data only (no state modification)
- Synchronous execution
- Returns DTOs (not DAOs)
- File naming: `xxx__query.py` in `queries/`
- Class naming: `XxxQuery`
- Implements `IXxxQuery` interface

**Query Rules:**
- No query handlers (direct execution)
- Uses infrastructure readers to get DAOs
- Uses mappers to convert DAOs to DTOs
- Returns DTOs to application layer

**Example:**
```python
class WalnutQuery(IWalnutQuery):
    def __init__(self, walnut_reader: IWalnutDBReader, walnut_mapper: IWalnutMapper):
        ...
    
    def get_by_id(self, walnut_id: str) -> Optional[WalnutDTO]:
        dao = self.walnut_reader.get_by_id(walnut_id)
        return self.walnut_mapper.dao_to_dto(dao) if dao else None
```

## Data Access Objects (DAOs)

**What is a DAO:**
- Represents database tables (SQLAlchemy ORM models)
- Lives in `infrastructure_layer/data_access_objects/`
- File naming: `xxx__db_dao.py` for database DAOs, `xxx__file_dao.py` for file system DAOs
- Class naming: `XxxDBDAO`, `XxxFileDAO`
- Contains only data, no business logic
- Can have relationships (SQLAlchemy relationships)

**What DAO is NOT:**
- NOT a domain entity
- NOT a DTO
- NOT a value object
- Does NOT contain business logic
- Does NOT know about domain layer

**DAO Rules:**
- Use SQLAlchemy 2.0 Annotated Declarative Table form
- Use `Class.__name__` or `Class.__tablename__` for relationship names (no magic strings)
- Use constants for ForeignKey table names
- DAOs are both ORM models and data objects

## Data Transfer Objects (DTOs)

**What is a DTO:**
- Simple data containers for transferring data between layers
- Lives in `application_layer/dtos/`
- File naming: `xxx__create_dto.py`, `xxx__read_dto.py`
- Class naming: `XxxCreateDTO`, `XxxDTO`, `XxxImageCreateDTO`
- No business logic
- Used in commands (CreateDTO) and queries (ReadDTO)

**DTO Types:**
- `CreateDTO`: For creating new entities (commands)
- `ReadDTO`: For reading data (queries)
- `UpdateDTO`: For updating entities (commands)
- `DeleteDTO`: For deleting entities (commands)
- and more

## Mappers

**What is a Mapper:**
- Converts between different representations (Entity ↔ DAO, Entity ↔ DTO, ValueObject ↔ DAO, ValueObject ↔ DTO, etc)
- Lives in `application_layer/mappers/`
- File naming: `xxx__mapper.py`
- Class naming: `XxxMapper`
- Implements `IXxxMapper` interface
- Injected via DI

**Mapper Rules:**
- Does NOT create entities (use domain factories instead)
- Entity → DAO mapping is allowed
- Entity → DTO mapping is allowed
- DAO → Entity mapping uses domain factories
- DTO → Entity mapping uses domain factories

**Example:**
```python
class WalnutMapper(IWalnutMapper):
    def file_dao_to_entity(self, file_dao: WalnutFileDAO) -> Either[WalnutEntity, DomainError]:
        # Convert to ImageValueObjects
        # Use WalnutDomainFactory.create_from_file_dao_images()
        pass
    
    def entity_to_dao(self, entity: WalnutEntity, ...) -> WalnutDBDAO:
        # Map entity fields to DAO
        # Use entity.id (not external ID)
        pass
```

## Dependency Injection (DI) / IoC Container

### Principles

1. **DI Only in Application and Infrastructure Layers**: Domain layer has no DI
2. **Interface-Based**: Dependencies are injected via interfaces (ABC)
3. **Automatic Resolution**: Container automatically resolves dependencies based on type hints
4. **Registration**: Interfaces are registered with implementations in `di_registry.py`

### Container Structure

- **Location**: `batch/di_container.py` (batch-specific)
- **Registry**: `batch/di_registry.py` (batch-specific)
- **Registration**: Interfaces → Implementations mapping

### DI Rules

1. **Interfaces**: Define in `common/interfaces.py` or layer-specific `__init__.py`
2. **Registration**: Register in `batch/di_registry.py`:
   ```python
   DIRegistry.register(IInterface, Implementation)
   ```
3. **Injection**: Use type hints in constructors:
   ```python
   def __init__(self, dependency: IDependency):
       self.dependency: IDependency = dependency
   ```
4. **No Manual Instantiation**: Never manually create dependencies, always inject

### What Gets DI

- **Application Layer**: Commands, queries, mappers, application services
- **Infrastructure Layer**: Readers, writers, file readers, services (image processing, etc.)
- **NOT Domain Layer**: Domain services and factories are static

## Infrastructure Services

**What is an Infrastructure Service:**
- Provides external capabilities not in domain services (e.g., image processing, external APIs)
- Lives in `infrastructure_layer/services/`
- File naming: `xxx__service.py`
- Class naming: `XxxService`
- Implements `IXxxService` interface
- Injected via DI

**Infrastructure Service Rules:**
- Contains technical/algorithmic logic (not business logic)
- Can use external libraries (OpenCV, PIL, numpy, etc.)
- Registered in DI container
- Used by application layer or command handlers

## File Naming Conventions

All files follow the pattern: `xxx__file_type.py`

**File Types:**
- `__entity.py`: Domain entities
- `__value_object.py`: Value objects
- `__domain_service.py`: Domain services (static)
- `__domain_factory.py`: Domain factories
- `__domain_error.py`: Domain errors
- `__command.py`: Command objects
- `__command_handler.py`: Command handlers
- `__query.py`: Query classes
- `__mapper.py`: Mapper classes
- `__dto.py`: Read DTOs
- `__create_dto.py`: Create DTOs
- `__db_dao.py`: Database DAOs
- `__file_dao.py`: File system DAOs
- `__db_reader.py`: Database readers
- `__db_writer.py`: Database writers
- `__file_reader.py`: File readers
- `__service.py`: Infrastructure services (external capabilities like image processing)
- `__al.py`: Application layer services

**Naming Consistency Rule:**
- **File name and class name must be consistent**: The class name must match the file name pattern
- Pattern: `{DomainConcept}{FileType}` where FileType corresponds to the file suffix
- Examples:
  - `dimension__value_object.py` → `WalnutDimensionValueObject` or `DimensionValueObject`
  - `walnut__entity.py` → `WalnutEntity`
  - `walnut__domain_service.py` → `WalnutDomainService`
  - `walnut__command.py` → `CreateWalnutCommand`
- This ensures consistency and makes it easy to find classes by file name

## Important Rules

1. **Layer Boundaries**: Never import from outer layers into inner layers
   - Domain layer: No imports from application or infrastructure
   - Application layer: Can import from domain, but not infrastructure (except via interfaces)
   - Infrastructure layer: Can import from domain (interfaces only)

2. **Entity Creation**: Always use factory methods or domain factories, never direct instantiation

3. **Error Handling**: Domain layer returns `Either`, application layer handles errors and logs

4. **ID Generation**: Entities generate their own IDs, never set from outside

5. **No Magic Strings**: Use enums, constants, or `Class.__name__` instead

6. **Type Hints**: All variables, parameters, and return values must have explicit type hints

7. **Imports**: All imports at the top of files, no inline imports

8. **Static Domain Services**: Domain services are static classes, no DI

9. **Mapper Separation**: Mappers don't create entities, factories do

10. **Query vs Command**: Queries read (return DTOs), Commands write (return None)

